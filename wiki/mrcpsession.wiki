<wiki:toc max_depth="3" />

mrcpsession. MRCP protocol implementation.

current mrcp implementation is built with UniMRCP stack. Please see UniMRCP configuration guide before running MRCP functionality.  The template configuration are packaged with ivrworx installer.


== `:new(...)` ==
_ctor_
creates mrcpsession object

== `:allocate(...)` ==
allocates mrcp session

|| *named parameter* || *description* ||
|| sdp || local side offer ||
|| resource || MRCP resource identifier see the table below ||
|| timeout || timeout for resource allocation ||

|| *resource id* || *description *||
|| SYNTHESIZER || MRCP synthesizer ||
|| RECOGNIZER || MRCP recognizer||


==   `:recognize(...)` ==
sends RECOGNIZE request to MRCP server

|| *named parameter* || *description* ||
|| grammar|| grammar put in body of request (may be uri, or any other body type) ||
|| sync || wait for recognition result ||

One may add different MRCP headers to the message

===generic parameters===
|| *named parameter*|| *type* ||
|| proxy_sync_id || string || 
|| accept_charset || string || 
|| content_type || string || 
|| content_id || string || 
|| content_base || string || 
|| content_encoding || string || 
|| content_location || string || 
|| cache_control || string || 
|| logging_tag || string || 
|| accept || string || 
|| fetch_timeout || number || 
|| set_cookie || string || 
|| set_cookie2 || string || 

=== recognize params ===
|| *named parameter*|| *type* ||
|| confidence_threshold || number || 
|| sensitivity_level || number || 
|| speed_vs_accuracy || number || 
|| n_best_list_length || number || 
|| no_input_timeout || number || 
|| recognition_timeout || number || 
|| waveform_uri || string || 
|| completion_cause || number || 
|| recognizer_context_block || string || 
|| start_input_timers || boolean || 
|| speech_complete_timeout || number || 
|| speech_incomplete_timeout || number || 
|| dtmf_interdigit_timeout || number || 
|| dtmf_term_timeout ||number  || 
|| dtmf_term_char || string || 
|| failed_uri || string || 
|| failed_uri_cause || number || 
|| save_waveform || string || 
|| new_audio_channel || bool || 
|| speech_language || string || 
|| input_type || string || 
|| input_waveform_uri || string || 
|| completion_reason || string || 
|| media_type || string || 
|| ver_buffer_utterance || boolean || 
|| recognition_mode || string || 
|| cancel_if_queue || boolean || 
|| hotword_max_duration || number || 
|| hotword_min_duration || number || 
|| interpret_text || string || 
|| dtmf_buffer_time || boolean || 
|| clear_dtmf_buffer || boolean || 
|| early_no_match || boolean || 


==   `:remoteoffer(...)` ==
remote offer

|| *named parameter* || *description* ||
|| resource|| channel resource id (see the table above)||

==   `:localoffer(...)` ==
local offer

|| *named parameter* || *description* ||
|| resource|| channel resource id (see the table above)||

== `:speak(...)` ==
Sends MRCP speak request.

|| *named parameter* || *description* ||
|| sentence || sentence to say ||
|| rawbody|| full body  ||
|| sync || wait for completion flag  ||


===synthesize parameters===

|| *named parameter*|| *type* ||
||jump_size|| number ||
||kill_on_barge_in|| boolean ||
||speaker_profile|| string ||
||completion_cause|| number ||
||completion_reason|| string ||
||voice_param|| TBD ||
||prosody_param|| TBD ||
||speech_marker|| string ||
||speech_language|| string ||
||fetch_hint|| string ||
||audio_fetch_hint|| string ||
||failed_uri|| string ||
||failed_uri_cause|| string ||
||speak_restart|| boolean  ||
||speak_length|| TBD ||
||load_lexicon|| boolean ||
||lexicon_search_order|| string ||

== `:stopspeak(...)` ==
Sends MRCP STOP SPEAK request.

== `:waitforrecog(...)`==
waits for recognition result
|| *named parameter*|| *type* ||
||timeout|| timeout ||

== example:simple ==

Pay attention that caller will receive traffic from port different then sending to. That may be a problem with some clients as linphone, as they correct SDP data thinking the NAT is involved

{{{
require "ivrworx"

local l	= assert(iw.LOGGER, "assert:iw.LOGGER")

--
-- set up first media call
--

caller = sipcall:new();
success(caller:makecall{dest="sip:24001@192.168.150.3"}); 

recog = mrcpsession:new();
success(recog:allocate{resource=iw.RECOGNIZER, sdp=caller:remoteoffer()});
success(caller:answer{sdp = recog:remoteoffer{resource=iw.RECOGNIZER}})

synth = mrcpsession:new();
success(synth:allocate{resource=iw.SYNTHESIZER, sdp=caller:remoteoffer()});


iw.sleep(1000);
success(synth:speak{sentence="Please choose red pill, or blue pill"});

pillgrammar=[[
<?xml version="1.0" encoding="UTF-8"?>
<!-- the default grammar language is US English -->
<grammar xmlns="http://www.w3.org/2001/06/grammar"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xml:lang="en-US" version="1.0" root="pill">
  <rule id="pill">
    <one-of>
      <item>red</item>
      <item>blue</item>
    </one-of> 
  </rule> 
</grammar>
]]

res, answer = recog:recognize{grammar=pillgrammar,sync=true, 
						cancel_if_queue=true, 
						content_id="<grammar1-borisu@form-level.store>",
						content_type="application/srgs+xml",
						no_input_timeout=20000,
						confidence_threshhold = 0.9,	
						start_input_timers=true};
						
if (res ~= iw.API_SUCCESS) then caller:hangup() end;

l:loginfo("=== RECOGNIZED START ===");						
l:loginfo(answer);						
l:loginfo("=== RECOGNIZED END ===");						

caller:waitforhangup();
}}}