= LUA API =

 * Ivrworx Result Code

 * Logging

 * Call Control

 * MRCP 

 * Simple Streaming

 * Utils 

 * SQLite

== Ivrworx Result Code ==

Most of the ivrworx functions return integer result code. For programmers convenience, the result constants are stored inside ivrworx table.

|| Constant key|| Meaning ||
|| ivrworx.API_SUCCESS|| Success. ||
|| ivrworx.API_FAILURE|| General failure.||
|| ivrworx.API_SERVER_FAILURE|| (not used)||
|| ivrworx.API_TIMEOUT|| Transaction timeout. ||
|| ivrworx.API_WRONG_PARAMETER|| Wrong parameter is passed to function. ||
|| ivrworx.API_WRONG_STATE|| The object upon which the function is called is in wrong state.||
|| ivrworx.API_HANGUP|| Remote party hanged up. ||
|| ivrworx.API_UNKNOWN_DESTINATION|| (internal) Destination process for message has died. ||
|| ivrworx.API_UNKNOWN_RESPONSE|| Received unknown response for request. ||
|| ivrworx.API_FEATURE_DISABLED|| The feature is disabled in configuration. ||

==Logging==

Ivrworx logger is a singleton object which is accessible via ivrworx table.

_*logger:loginfo()*_

_*logger:logwarn()*_

_*logger:logcrit()*_

_*logger:logdebug()*_

{{{
logger = assert(ivrworx.LOGGER);

logger.loginfo("INF message");
logger.loginfo("WRN message");
logger.loginfo("CRT message");
logger.loginfo("DBG message");
}}}

==Call Control==

Call objects are created by calling _ivrworx:createcall_ function.

{{{

call = ivrworx.createcall();

}}}

For incoming IVR calls there's a built-in _ivrworx.INCOMING_ object which designates the incoming call.

{{{

incoming = assert(ivrworx.INCOMING);

}}}

----

_*call:makecall(dest)*_

Makes call to sip destination.

{{{

call = ivrworx.createcall();
res = call:makecall("sip:1234@example.com:5060");

}}}


----

_*call:answer()*_


Answers incoming call, e.g. codecs are negotiated and 200 OK is sent to UAC. Returns result code. 


{{{
 
incoming = assert(ivrworx.INCOMING);
res = incoming:answer();

}}}

----

_*call:hangup()*_

Hangs up the call.

{{{

res = call:hangup();

}}}

---

_*call:waitforhangup()*_

Waits till remote party hangs up.

{{{

res = call:waitforhangup();

}}}

----

_*call:ani()*_

_*call:dnis()*_

Returns ANI and DNIS of the call.

{{{

ani = call:ani();
dnis = call:dnis();

ivrworx.loginfo("ANI="..ani..", DNIS="..dnis);

}}}

----

_*call:cleandtmfbuffer*_

Cleans dtmf digits' buffer.

{{{

call:cleandtmfbuffer();

}}}

----

_*call:waitfordtmf(timeout)_

Waits timeout or returns DTMF digit (SIP INFO) which is placed in current DTMF buffer. Returns result code and DTMF digit in string format (nil in case of timeout).

{{{

res,curr_dtmf = incoming:waitfordtmf(interdigit_timeout);

if (res == ivrworx.API_SUCCESS) then
  logger:loginfo("Received DTMF="...curr_dtmf);
end

}}}

----

_*call:blindxfer(dest)*_

Blind transfer of established call to sip destination.

{{{

call = ivrworx.createcall();
res = call:makecall("sip:1234@example.com:5060");

if (res == ivrworx.API_SUCCESS) then
 res = call:blindxfer("sip:1234@example.com");
end

}}}
----

==Simple Streaming API==

_*call:play(file,sync,loop)*_

Streams _file_ to remote party. File has to be in WAV format PCM encoding. No file format checks are performed.

sync - play will exit when stream is finished, or immediately otherwise.

loop - will play the file in loops (cannot be used with sync equal true).

{{{

res = call:play("c:\\Welcome.wav",true,false);
logger:loginfo("Streaming has finished...");

}}}

----

_*call:stopplay()*_

Stops streaming.

{{{

--
-- Sleep one second, then stop streaming.
--

call:play("c:\\Welcome.wav",false,false);
ivrworx.sleep(1000);
call:stopplay();

}}}

==MRCP==

_*call:speakmrcp(mrcp, sync)*_

Sends TTS request to MRCP server. The body of request is _speakmrcp_ parameter.

sync - if sync is true the function will return only after "speaking" is over, or immediately otherwise

{{{

mrcp_goodbye = [[<?xml version="1.0"?>
<speak>
  <paragraph>
    <sentence>Thank you.</sentence><sentence>And good bye.</sentence>
  </paragraph>
</speak>]]

res = incoming:speak(mrcp_goodbye,true);

}}}

----

_*call:speak(tts, sync)*_

build simple TTS xml and sends it to MRCP server.

sync - if sync is true the function will return only after "speaking" is over, or immediately otherwise

{{{

call:speak("Welcome!",true);

}}}

----

_*call:stopspeak()*_

Stops current "speaking"

{{{

--
-- Sleep one second, then stop speaking.
--

call:speak("Welcome!",false
ivrworx.sleep(1000);
call:stopspeak();

}}}

==Utils==

_*ivrworx.sleep(timeout)*_

Fiber non blocking sleep. Param is passed in milliseconds

{{{
ivrworx.sleep(1000);
}}}

==SQLite==


Lua [http://www.keplerproject.org/luasql/manual.html#drivers SQLite driver] from [http://www.keplerproject.org/luasql/ kepler] project. Was ported to ivrworx in order to provide non blocking fiber API. The API hasn't changed. The libraries are loaded automatically into lua vm at start up time (no _require_ keyword is needed).

{{{
env = assert(luasql.sqlite3());
conn_string = assert(conf:getstring("polly_db"));
con = assert(env:connect(conn_string));

logger:loginfo("db:"..conn_string.." open");

}}} 